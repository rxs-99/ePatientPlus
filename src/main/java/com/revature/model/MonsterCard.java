package com.revature.model;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.revature.exception.CardNotFaceUpException;


/*
 * Hibernate allows us to use an annotation-driven approach to mapping our
 * Java models to the entities within our database.
 */

/*
 * Note that the annotations that we use for mapping our models come from the
 * Java Persistence API - NOT Hibernate as Hibernate's versions of these
 * annotations are deprecated.
 * 
 * @Entity marks this class as an entity, meaning that we intend to map this
 * class to a table in our database.
 */
@Entity

/*
 * This annotation allows us to specify information about the table we want
 * associated with our model. You can specify, for instance, the table's name
 * (in the database), though you don't have to because Hibernate will use
 * the model's name as the table name if no name is specified here.
 */
@Table(name = "monster_card") 
public class MonsterCard extends GenericCard implements Serializable, Comparable<MonsterCard> {
	
	private static final long serialVersionUID = 1L;
	
	/*
	 * This denotes that we wish to use this field as the primary key
	 * on our table. We use it in conjunction with the @GeneratedValue
	 * annotation to specify that this Id is autogenerated (e.g. generated
	 * by a sequence). We also use the @SequenceGenerator annotation to define
	 * the sequence that should be used to generate that value.
	 */
	@Id
	@Column(name = "monster_card_id")
	@GeneratedValue(generator = "monster_card_id_seq", strategy = GenerationType.AUTO)
	@SequenceGenerator(allocationSize = 1, name = "monster_card_id_seq", sequenceName = "monster_card_id_seq")
	private int id;
	/*
	 * The @Column annotation denotes that we want this field to represent a
	 * column on our table.
	 */
	@Column
	private transient int health;
	/*
	 * Using this annotation, we are creating a many-to-one relationship
	 * between our MonsterCard entity and our Realm entity.
	 */
	@JoinColumn //Don't forget to make it a JoinColumn
	@ManyToOne
	private Realm realm;
	
	/*
	 * Hibernate can even create our join tables for us if we use the 
	 * @ManyToMany annotation along with the @JoinTable annotation.
	 */
	
	@ManyToMany
	@JoinTable(joinColumns = {@JoinColumn(name = "monster_card_id")}, 
	inverseJoinColumns = {@JoinColumn(name = "card_class_id")})
	private Set<CardClass> cardClass;
	
	public static int numCardsCreated;
	private final int maxNumCards;
	
	/*
	 * This is referred to as an instance initializer. It is a block of code
	 * which is run every single time you create an instance of this class.
	 */
	{
		maxNumCards = 8;
	}

	public MonsterCard() {
		// This a no-args constructor.
		numCardsCreated++;
	}

	public MonsterCard(int id, String name, int health, boolean faceUp, Realm realm, Set<CardClass> cardClass) {
		this.id = id;
		this.name = name;
		this.health = health;
		this.faceUp = faceUp;
		this.difficultyLevel = 0;
		this.realm = realm;
		this.cardClass = cardClass;
		numCardsCreated++;
	}
	
	/*
	 * This method simulates a card being played. It can only be
	 * played if it's face up.
	 */
	public void play() throws CardNotFaceUpException {
		if(this.faceUp == false) {
			throw new CardNotFaceUpException();
		}
		System.out.println("Playing this card!");
	}
	
	public int getId() {
		return this.id;
	}
	
	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		if (name.length() > 0) {
			this.name = name;
		} else {
			this.name = "default name";
		}
	}

	public int getHealth() {
		return health;
	}

	public void setHealth(int health) {
		this.health = health;
	}

	public boolean isFaceUp() {
		return faceUp;
	}

	public void setFaceUp(boolean faceUp) {
		this.faceUp = faceUp;
	}
	
	public int getDifficultyLevel() {
		return this.difficultyLevel;
	}
	
	public void setDifficultyLevel(int difficultyLevel) {
		this.difficultyLevel = difficultyLevel;
	}
	
	public Realm getRealm() {
		return this.realm;
	}
	
	public void setRealm(Realm realm) {
		this.realm = realm;
	}

	public Set<CardClass> getCardClass() {
		return this.cardClass;
	}
	
	public void setCardClass(Set<CardClass> cardClass) {
		this.cardClass = cardClass;
	}


	@Override
	public String toString() {
		return "MonsterCard [id=" + id + ", health=" + health + ", realm=" + realm + ", maxNumCards=" + maxNumCards
				+ ", name=" + name + ", faceUp=" + faceUp + ", difficultyLevel=" + difficultyLevel + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		MonsterCard other = (MonsterCard) obj;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}

	/*
	 * When we say that MonsterCard is overriding a method, we say that it
	 * is providing a different implementation for a method that it has
	 * inherited.
	 */
	@Override
	public void printDifficultyManual() {
		System.out.println("Not yet implemented");
	}
	
	/*
	 * This is a method overload. Note that you must change either:
	 * 
	 * 1. The number of parameters.
	 * 2. The types of the parameters.
	 * 
	 * Of course you can have as many overloads as you want.
	 * 
	 * Note that this method is now final. This means that any class which
	 * inherits it cannot override it. It can, however, still be overloaded
	 * in this class as you see below!
	 */
	public final void printDifficultyManual(String instructions) {
		
	}
	
	public void printDifficultyManual(String instructions, String creator) {
		
	}

	/*
	 * I must define my criteria for sorting MonsterCards within this method!
	 */
	@Override
	public int compareTo(MonsterCard o) {
		
		if(this.health < o.health) {
			return -1;
		} else if(this.health > o.health){
			return 1;
		}
		return 0;
	}

}

/*
 * We are NOT allowed to extend a final class.
 */
class MageCard /*extends MonsterCard*/{
	
}